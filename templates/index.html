<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questje's ReQuestje's</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <h1>üéµ Questje's ReQuestje's Charts üéµ </h1>
                <!-- Auth section - persists across all pages -->
                <div class="auth-section" id="authSection">
                    <!-- Login/User info will be inserted here by JavaScript -->
                </div>
            </div>
            <div class="controls">
                <button id="prevChart" class="nav-button">
                    ‚Üê PREVIOUS
                </button>
                
                <div class="chart-selector-group">
                    <label for="chartSelector">Select Chart:</label>
                    <select id="chartSelector">
                        {% if has_data %}
                            <option value="0">All Songs</option>
                            {% for i in range(1, num_charts + 1) %}
                                <option value="{{ i }}" {% if i == num_charts %}selected{% endif %}>
                                    Chart {{ i }}
                                </option>
                            {% endfor %}
                        {% else %}
                            <option value="0">No Data Available</option>
                        {% endif %}
                    </select>
                </div>
                
                <button id="nextChart" class="nav-button">
                    NEXT ‚Üí
                </button>
                
                <span id="loadingIndicator" class="loading-hidden">Loading...</span>
            </div>
        </header>

        <main>
            {% if has_data %}
                <h2>
                  Questje's ReQuestje's #<span id="currentChart"></span>
                </h2>
                
                <!-- Filters Section -->
                <div class="filters-container">
                    <div class="filter-group">
                        <label for="songFilter">Filter by Song:</label>
                        <input type="text" id="songFilter" placeholder="Type to search..." class="song-filter-input">
                        <button id="clearFilter" class="clear-filter-btn">Clear</button>
                    </div>
                    <div class="filter-status" id="filterStatus"></div>
                </div>
                
                <div class="chart-legend" id="chartLegend">
                    <span class="legend-item clickable" data-filter="new"><span class="legend-color new"></span> New Entry <span class="count" id="countNew">(0)</span></span>
                    <span class="legend-item clickable" data-filter="riser"><span class="legend-color riser"></span> Riser <span class="count" id="countRiser">(0)</span></span>
                    <span class="legend-item clickable" data-filter="same"><span class="legend-color same"></span> No Change <span class="count" id="countSame">(0)</span></span>
                    <span class="legend-item clickable" data-filter="faller"><span class="legend-color faller"></span> Faller <span class="count" id="countFaller">(0)</span></span>
                    <span class="legend-item clickable" data-filter="reentry"><span class="legend-color reentry"></span> Re-entry <span class="count" id="countReentry">(0)</span></span>
                </div>
                
                <table id="chartTable">
                    <thead>
                        <tr>
                            <th data-column="position" class="sortable compact-column">
                                Pos <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="prev_position" class="sortable compact-column">
                                Prev <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="title" class="sortable song-title-column">
                                Song Title <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="total_charts" class="sortable charts-column">
                                Charts <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="top_spot" class="sortable top-spot-column">
                                Top Spot <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="total_points" class="sortable points-column">
                                Total Points <span class="sort-arrow">‚Üï</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="chartBody">
                        <!-- Data will be loaded here via JavaScript -->
                    </tbody>
                </table>
            {% else %}
                <div class="error-message">
                    <h2>‚ö†Ô∏è No Data Available</h2>
                    <p>Please ensure the Chart.xlsx file is in the correct location and properly formatted.</p>
                </div>
            {% endif %}
        </main>

        <footer>
            <p>Questje's ReQuestje's ¬© 2025 | <span id="songCount"></span> total songs across <span id="chartCount"></span> charts</p>
        </footer>
    </div>

    <!-- Chart History Popup -->
    <div id="chartHistoryPopup" class="chart-history-popup" style="display: none;">
        <div class="popup-header">
            <span id="popupSongTitle"></span>
            <button id="closePopup" class="close-popup">√ó</button>
        </div>
        <canvas id="historyChart" width="300" height="150"></canvas>
        <div id="chartTooltipContainer" class="chart-tooltip-container"></div>
    </div>

    <script>
        let currentData = [];
        let filteredData = [];
        let currentSortColumn = 'position';
        let currentSortDirection = 'asc';
        let currentChartNumber = {{ num_charts if has_data else 1 }};
        const maxCharts = {{ num_charts if has_data else 1 }};
        let currentHoverTimeout = null;
        let activeMovementFilter = null;
        let activeSongFilter = '';
        let currentUser = null;
        let currentUserProfilePic = null;

        // Show tooltip for points cell with position stats
        function showPointsTooltip(event, stats) {
            const tooltip = document.createElement('div');
            tooltip.className = 'points-tooltip';
            tooltip.id = 'pointsTooltip';
            
            let html = '<div class="points-tooltip-content">';
            let hasStats = false;
            
            if (stats.num_ones > 0) {
                html += `<div class="tooltip-stat">#1: <strong>${stats.num_ones}</strong> ${stats.num_ones === 1 ? 'time' : 'times'}</div>`;
                hasStats = true;
            }
            if (stats.num_top3 > 0) {
                html += `<div class="tooltip-stat">Top 3: <strong>${stats.num_top3}</strong> ${stats.num_top3 === 1 ? 'time' : 'times'}</div>`;
                hasStats = true;
            }
            if (stats.num_top10 > 0) {
                html += `<div class="tooltip-stat">Top 10: <strong>${stats.num_top10}</strong> ${stats.num_top10 === 1 ? 'time' : 'times'}</div>`;
                hasStats = true;
            }
            
            if (!hasStats) {
                html += `<div class="tooltip-stat">No Top 10s</div>`;
            }
            
            html += '</div>';
            
            tooltip.innerHTML = html;
            document.body.appendChild(tooltip);
            
            // Position the tooltip
            const rect = event.target.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            // Check if we're in the Total Points column (rightmost column) - position to the left
            const pointsColumn = event.target.closest('td.points-cell');
            if (pointsColumn) {
                // Always position to the left for Total Points column
                const left = rect.left - tooltip.offsetWidth - 15;
                const top = rect.top + rect.height / 2 - tooltip.offsetHeight / 2;
                tooltip.style.left = Math.max(5, left) + 'px';
                tooltip.style.top = top + 'px';
            } else {
                // Default positioning for other columns
                let left = rect.left + rect.width / 2;
                let top = rect.top - tooltip.offsetHeight - 8;
                
                // Check if tooltip goes off right edge of screen
                if (left + tooltip.offsetWidth / 2 > window.innerWidth - 10) {
                    left = rect.left - tooltip.offsetWidth - 10;
                    top = rect.top + rect.height / 2 - tooltip.offsetHeight / 2;
                }
                // Check if tooltip goes off left edge of screen
                else if (left - tooltip.offsetWidth / 2 < 10) {
                    left = rect.right + 10;
                    top = rect.top + rect.height / 2 - tooltip.offsetHeight / 2;
                } else {
                    left = left - tooltip.offsetWidth / 2;
                }
                
                // Ensure tooltip stays within vertical bounds
                if (top < 10) {
                    top = rect.bottom + 8;
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            }
        }

        function hidePointsTooltip() {
            const tooltip = document.getElementById('pointsTooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Show tooltip for #1 labels
        function showNumberOneTooltip(event, charts) {
            const tooltip = document.createElement('div');
            tooltip.className = 'number-one-tooltip';
            tooltip.id = 'numberOneTooltip';
            
            if (charts.length === 1) {
                tooltip.textContent = `#1 in Chart ${charts[0]}`;
            } else {
                const chartList = charts.map(c => `Chart ${c}`).join(', ');
                tooltip.textContent = `#1 in: ${chartList}`;
            }
            
            document.body.appendChild(tooltip);
            
            // Position the tooltip above the label
            const rect = event.target.getBoundingClientRect();
            tooltip.style.position = 'fixed';
            tooltip.style.left = (rect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
            tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
        }

        function hideNumberOneTooltip() {
            const tooltip = document.getElementById('numberOneTooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Check authentication status on page load
        async function checkAuth() {
            try {
                const response = await fetch('/api/auth/status');
                const data = await response.json();
                if (data.logged_in) {
                    currentUser = data.username;
                    currentUserProfilePic = data.profile_pic;
                }
                updateAuthDisplay();
            } catch (error) {
                console.error('Failed to check auth status:', error);
            }
        }

        // Update auth display in header
        function updateAuthDisplay() {
            const authSection = document.getElementById('authSection');
            
            if (currentUser) {
                // Build user info HTML with profile pic
                let html = '<div class="user-info">';
                html += `<span class="username">Logged in as: <strong>${currentUser}</strong></span>`;
                if (currentUserProfilePic) {
                    html += `<img src="${currentUserProfilePic}" alt="${currentUser}" class="profile-pic-small">`;
                }
                html += '<i class="fab fa-twitch"></i>';
                html += '<button class="logout-btn" onclick="logout()">Logout</button>';
                html += '</div>';
                authSection.innerHTML = html;
            } else {
                authSection.innerHTML = `
                    <button class="login-btn" onclick="loginWithTwitch()">
                        <i class="fab fa-twitch"></i> Login with Twitch
                    </button>
                `;
            }
        }

        // Login with Twitch
        function loginWithTwitch() {
            window.location.href = '/auth/login';
        }

        // Logout
        async function logout() {
            try {
                const response = await fetch('/auth/logout', { method: 'POST' });
                if (response.ok) {
                    currentUser = null;
                    currentUserProfilePic = null;
                    location.reload();
                }
            } catch (error) {
                console.error('Failed to logout:', error);
            }
        }

        // Load chart data
        async function loadChart(chartNumber) {
            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.classList.remove('loading-hidden');
            
            try {
                const response = await fetch(`/api/chart/${chartNumber}`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading chart:', data.error);
                    return;
                }
                
                currentData = data.data;
                filteredData = [...currentData];
                currentChartNumber = chartNumber;
                currentSortColumn = 'position';
                currentSortDirection = 'asc';
                document.getElementById('currentChart').textContent = data.chart_number ? data.chart_number : "ALL-TIME"
                
                // Reset filters when changing charts
                activeMovementFilter = null;
                activeSongFilter = '';
                document.getElementById('songFilter').value = '';
                updateFilterStatus();
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active-filter');
                });

                // Update selector
                document.getElementById('chartSelector').value = currentChartNumber;
                
                // Update button states
                updateNavigationButtons();
                
                // Update legend counts
                updateLegendCounts(data.movement_counts);
                
                // Show/hide legend based on chart type and update clickability
                const legend = document.getElementById('chartLegend');
                if (chartNumber === 0) {
                    legend.style.display = 'none';
                    document.querySelectorAll('.legend-item').forEach(item => {
                        item.classList.remove('clickable');
                    });
                } else {
                    legend.style.display = 'flex';
                    document.querySelectorAll('.legend-item').forEach(item => {
                        item.classList.add('clickable');
                    });
                }
                
                renderTable();
            } catch (error) {
                console.error('Failed to load chart:', error);
            } finally {
                loadingIndicator.classList.add('loading-hidden');
            }
        }

        // Update legend counts
        function updateLegendCounts(counts) {
            if (counts) {
                document.getElementById('countNew').textContent = `(${counts.new || 0})`;
                document.getElementById('countRiser').textContent = `(${counts.riser || 0})`;
                document.getElementById('countSame').textContent = `(${counts.same || 0})`;
                document.getElementById('countFaller').textContent = `(${counts.faller || 0})`;
                document.getElementById('countReentry').textContent = `(${counts.reentry || 0})`;
            }
        }

        // Update navigation button states
        function updateNavigationButtons() {
            document.getElementById('prevChart').disabled = currentChartNumber <= 0;
            document.getElementById('nextChart').disabled = currentChartNumber >= maxCharts;
        }

        // Navigate to previous/next chart
        function navigateChart(direction) {
            const newChartNumber = currentChartNumber + direction;
            if (newChartNumber >= 0 && newChartNumber <= maxCharts) {
                loadChart(newChartNumber);
            }
        }

        // Format song title with #1 label
        function formatSongTitle(title, numberOnes, numberOneCharts) {
            if (numberOnes > 0) {
                return `<span class="song-title-text">${title}</span> <span class="number-one-label" data-charts='${JSON.stringify(numberOneCharts)}'>${numberOnes}x #1</span>`;
            }
            return `<span class="song-title-text">${title}</span>`;
        }

        // Show chart history popup
        async function showChartHistory(songTitle, event) {
            try {
                const response = await fetch(`/api/song-history/${encodeURIComponent(songTitle)}`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading song history:', data.error);
                    return;
                }
                
                const popup = document.getElementById('chartHistoryPopup');
                const canvas = document.getElementById('historyChart');
                const ctx = canvas.getContext('2d');
                
                // Set popup title
                document.getElementById('popupSongTitle').textContent = data.title;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (data.chart_data.length === 0) {
                    ctx.fillStyle = '#666';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No chart data available', canvas.width / 2, canvas.height / 2);
                } else {
                    // Draw the chart
                    drawLineChart(ctx, canvas, data.chart_data, currentChartNumber);
                }
                
                // Position popup near the mouse, but keep it within viewport
                const rect = popup.getBoundingClientRect();
                let left = event.pageX + 10;
                let top = event.pageY - rect.height / 2;
                
                // Adjust if popup would go off screen
                if (left + rect.width > window.innerWidth) {
                    left = event.pageX - rect.width - 10;
                }
                if (top < 10) {
                    top = 10;
                } else if (top + rect.height > window.innerHeight - 10) {
                    top = window.innerHeight - rect.height - 10;
                }
                
                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
                popup.style.display = 'block';
                
            } catch (error) {
                console.error('Failed to load song history:', error);
            }
        }

        // Draw line chart for song history with visible position labels on all data points
        function drawLineChart(ctx, canvas, data, currentChart) {
            const padding = 25;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Filter data to only include charts up to currentChart
            const filteredData = currentChart === 0 ? data : data.filter(d => d.chart <= currentChart);
            
            if (filteredData.length === 0) return;
            
            // Find min and max values
            const positions = filteredData.map(d => d.position);
            const maxPosition = Math.max(...positions);
            const minPosition = Math.min(...positions);
            const positionRange = maxPosition - minPosition || 1;
            
            const charts = filteredData.map(d => d.chart);
            const minChart = Math.min(...charts);
            const maxChart = Math.max(...charts);
            const chartRange = maxChart - minChart || 1;
            
            // Draw axes
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Add axis labels
            ctx.fillStyle = '#999';
            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            
            // Y-axis labels
            ctx.save();
            ctx.translate(10, padding);
            ctx.textAlign = 'right';
            ctx.fillText(`#${minPosition}`, 0, 5);
            ctx.restore();
            
            ctx.save();
            ctx.translate(10, canvas.height - padding);
            ctx.textAlign = 'right';
            ctx.fillText(`#${maxPosition}`, 0, -2);
            ctx.restore();
            
            // X-axis labels
            ctx.textAlign = 'center';
            ctx.fillText(`${minChart}`, padding, canvas.height - padding + 12);
            ctx.fillText(`${maxChart}`, canvas.width - padding, canvas.height - padding + 12);
            
            // Draw the line
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            filteredData.forEach((point, index) => {
                const x = padding + ((point.chart - minChart) / chartRange) * width;
                const y = padding + ((point.position - minPosition) / positionRange) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points and position labels - ALWAYS VISIBLE
            ctx.fillStyle = '#3498db';
            filteredData.forEach((point) => {
                const x = padding + ((point.chart - minChart) / chartRange) * width;
                const y = padding + ((point.position - minPosition) / positionRange) * height;
                
                // Draw circle for data point
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // ALWAYS show position label above the point
                ctx.fillStyle = '#333';
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`#${point.position}`, x, y - 9);
                ctx.fillStyle = '#3498db';
                
                // Highlight #1 positions
                if (point.position === 1) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.strokeStyle = '#3498db';
                }
            });

            // Set up hover interaction - store data for reuse
            const canvas_elem = document.getElementById('historyChart');
            
            // Remove old listeners to prevent duplicates
            canvas_elem.onmousemove = function(e) {
                const rect = canvas_elem.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Find nearest point with larger hitbox
                let nearest = null;
                let minDist = Infinity;

                filteredData.forEach((point) => {
                    const x = padding + ((point.chart - minChart) / chartRange) * width;
                    const y = padding + ((point.position - minPosition) / positionRange) * height;

                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                    // 25px hitbox for reliable hover
                    if (dist < minDist && dist < 25) {
                        minDist = dist;
                        nearest = { ...point, px: x, py: y };
                    }
                });

                if (nearest) {
                    showChartTooltip(e, nearest);
                    canvas_elem.style.cursor = 'pointer';
                } else {
                    hideChartTooltip();
                    canvas_elem.style.cursor = 'default';
                }
            };

            canvas_elem.onmouseleave = function() {
                hideChartTooltip();
                canvas_elem.style.cursor = 'default';
            };
        }

        // Show tooltip for chart data point with format "#3 (Chart 2)"
        function showChartTooltip(e, point) {
            const tooltip = document.getElementById('chartTooltipContainer');
            tooltip.innerHTML = `<div class="chart-tooltip">#${point.position} (Chart ${point.chart})</div>`;
            tooltip.style.display = 'block';
            tooltip.style.left = e.clientX + 'px';
            tooltip.style.top = (e.clientY - 25) + 'px';
        }

        // Hide tooltip for chart data point
        function hideChartTooltip() {
            document.getElementById('chartTooltipContainer').style.display = 'none';
        }

        // Hide chart history popup
        function hideChartHistory() {
            document.getElementById('chartHistoryPopup').style.display = 'none';
        }
        
        // Apply filters to data
        function applyFilters() {
            filteredData = [...currentData];
            
            if (activeSongFilter) {
                filteredData = filteredData.filter(song => 
                    song.title.toLowerCase().includes(activeSongFilter.toLowerCase())
                );
            }
            
            if (activeMovementFilter && currentChartNumber !== 0) {
                filteredData = filteredData.filter(song => 
                    song.movement_type === activeMovementFilter
                );
            }
            
            updateFilterStatus();
            renderTable();
        }
        
        // Update filter status message
        function updateFilterStatus() {
            const statusEl = document.getElementById('filterStatus');
            const filters = [];
            
            if (activeSongFilter) {
                filters.push(`Song contains "${activeSongFilter}"`);
            }
            
            if (activeMovementFilter) {
                const filterNames = {
                    'new': 'New Entries',
                    'riser': 'Risers',
                    'faller': 'Fallers',
                    'same': 'No Change',
                    'reentry': 'Re-entries'
                };
                filters.push(filterNames[activeMovementFilter]);
            }
            
            if (filters.length > 0) {
                statusEl.innerHTML = `<strong>Active filters:</strong> ${filters.join(' | ')} <span class="results-count">(${filteredData.length} results)</span>`;
                statusEl.style.display = 'block';
            } else {
                statusEl.style.display = 'none';
            }
        }

        // Render table with current data
        function renderTable() {
            const tbody = document.getElementById('chartBody');
            tbody.innerHTML = '';
            
            const isAllSongs = currentChartNumber === 0;
            
            if (filteredData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-results">No songs match the current filters</td></tr>';
                return;
            }
            
            filteredData.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = 'chart-row';
                
                // Make entire row clickable to go to song page
                tr.addEventListener('click', () => {
                    // Store current chart number in sessionStorage for back navigation
                    sessionStorage.setItem('lastChartNumber', currentChartNumber);
                    window.location.href = `/song/${encodeURIComponent(row.title)}`;
                });
                
                // Add hover events for chart history
                tr.addEventListener('mouseenter', (e) => {
                    clearTimeout(currentHoverTimeout);
                    currentHoverTimeout = setTimeout(() => {
                        showChartHistory(row.title, e);
                    }, 500);
                });
                
                tr.addEventListener('mouseleave', () => {
                    clearTimeout(currentHoverTimeout);
                    setTimeout(() => {
                        const popup = document.getElementById('chartHistoryPopup');
                        if (!popup.matches(':hover')) {
                            hideChartHistory();
                        }
                    }, 100);
                });
                
                // Determine position box class based on movement type
                let positionClass = 'position-number';
                let movementIcon = '';
                
                if (!isAllSongs) {
                    switch(row.movement_type) {
                        case 'new':
                            positionClass += ' new-entry';
                            movementIcon = '<span class="movement-icon">‚òÖ</span>';
                            break;
                        case 'reentry':
                            positionClass += ' reentry';
                            movementIcon = '<span class="movement-icon">‚Ü∫</span>';
                            break;
                        case 'riser':
                            positionClass += ' riser';
                            movementIcon = '<span class="movement-icon">‚Üë</span>';
                            break;
                        case 'faller':
                            positionClass += ' faller';
                            movementIcon = '<span class="movement-icon">‚Üì</span>';
                            break;
                        case 'same':
                            positionClass += ' same';
                            movementIcon = '<span class="movement-icon">‚Üí</span>';
                            break;
                    }
                } else {
                    if (row.position <= 3) {
                        positionClass += ' top-three';
                    } else if (row.position <= 10) {
                        positionClass += ' top-ten';
                    } else {
                        positionClass += ' same';
                    }
                }
                
                const topSpotColor = '#474747ff';
                const topSpotDisplay = row.top_spot ? 
                    `<span style="color: ${topSpotColor}; font-weight: bold;">${row.top_spot}</span>` : 
                    '<span style="color: #999;">--</span>';
                
                tr.innerHTML = `
                    <td class="position-cell compact-cell">
                        <div class="position-wrapper">
                            <span class="${positionClass}">${row.position}</span>
                            ${movementIcon}
                        </div>
                    </td>
                    <td class="prev-position-cell compact-cell">${row.prev_position}</td>
                    <td class="title-cell">${formatSongTitle(row.title, row.number_ones, row.number_one_charts)}</td>
                    <td class="charts-cell compact-cell">${row.total_charts}</td>
                    <td class="top-spot-cell compact-cell">
                        ${topSpotDisplay}
                    </td>
                    <td class="points-cell compact-cell" data-stats='${JSON.stringify(row.position_stats)}'>${row.total_points}</td>
                `;
                
                tbody.appendChild(tr);

                // Add hover events for points tooltip
                const pointsCell = tr.querySelector('.points-cell');
                if (pointsCell && row.position_stats) {
                    pointsCell.addEventListener('mouseenter', (e) => {
                        showPointsTooltip(e, row.position_stats);
                    });
                    
                    pointsCell.addEventListener('mouseleave', () => {
                        hidePointsTooltip();
                    });
                }

                // Add hover events for #1 labels
                const numberOneLabel = tr.querySelector('.number-one-label');
                if (numberOneLabel && row.number_one_charts) {
                    numberOneLabel.addEventListener('mouseenter', (e) => {
                        showNumberOneTooltip(e, row.number_one_charts);
                    });
                    
                    numberOneLabel.addEventListener('mouseleave', () => {
                        hideNumberOneTooltip();
                    });
                }

            });
        }

        // Sort table
        function sortTable(column) {
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = column === 'total_points' ? 'desc' : 'asc';
            }
            
            filteredData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];
                
                if (column === 'prev_position') {
                    aVal = aVal === '--' ? 999 : parseInt(aVal);
                    bVal = bVal === '--' ? 999 : parseInt(bVal);
                }
                
                if (column === 'top_spot') {
                    aVal = aVal === null || aVal === undefined ? 999 : aVal;
                    bVal = bVal === null || bVal === undefined ? 999 : bVal;
                }
                
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (currentSortDirection === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            renderTable();
            updateSortIndicators();
        }

        // Update sort indicators
        function updateSortIndicators() {
            document.querySelectorAll('th.sortable').forEach(th => {
                const arrow = th.querySelector('.sort-arrow');
                if (th.dataset.column === currentSortColumn) {
                    arrow.textContent = currentSortDirection === 'asc' ? '‚Üë' : '‚Üì';
                    arrow.className = 'sort-arrow ' + currentSortDirection;
                    th.classList.add('sorted');
                } else {
                    arrow.textContent = '‚Üï';
                    arrow.className = 'sort-arrow';
                    th.classList.remove('sorted');
                }
            });
        }

        // Load general info
        async function loadInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                document.getElementById('songCount').textContent = data.num_songs;
                document.getElementById('chartCount').textContent = data.num_charts;
            } catch (error) {
                console.error('Failed to load info:', error);
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkAuth();

            {% if has_data %}
                // Check if there's a chart parameter in the URL
                const urlParams = new URLSearchParams(window.location.search);
                const chartParam = urlParams.get('chart');
                let initialChart = {{ num_charts }};
                
                if (chartParam !== null) {
                    const chartNumber = parseInt(chartParam);
                    if (!isNaN(chartNumber) && chartNumber >= 0 && chartNumber <= {{ num_charts }}) {
                        initialChart = chartNumber;
                    }
                }
                
                loadChart(initialChart);
                loadInfo();
                
                document.querySelector('.filters-container').style.display = 'flex';
            {% endif %}
            
            document.getElementById('chartSelector').addEventListener('change', (e) => {
                loadChart(parseInt(e.target.value));
            });
            
            document.getElementById('prevChart').addEventListener('click', () => {
                navigateChart(-1);
            });
            
            document.getElementById('nextChart').addEventListener('click', () => {
                navigateChart(1);
            });
            
            document.getElementById('closePopup').addEventListener('click', hideChartHistory);
            
            document.getElementById('chartHistoryPopup').addEventListener('mouseenter', () => {
                clearTimeout(currentHoverTimeout);
            });
            
            document.getElementById('chartHistoryPopup').addEventListener('mouseleave', hideChartHistory);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && !e.target.matches('input, select, textarea')) {
                    navigateChart(-1);
                } else if (e.key === 'ArrowRight' && !e.target.matches('input, select, textarea')) {
                    navigateChart(1);
                } else if (e.key === 'Escape') {
                    hideChartHistory();
                }
            });
            
            document.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    sortTable(th.dataset.column);
                });
            });
            
            document.getElementById('songFilter').addEventListener('input', (e) => {
                activeSongFilter = e.target.value.trim();
                applyFilters();
            });
            
            document.getElementById('clearFilter').addEventListener('click', () => {
                document.getElementById('songFilter').value = '';
                activeSongFilter = '';
                applyFilters();
            });
            
            document.querySelectorAll('.legend-item.clickable').forEach(item => {
                item.addEventListener('click', () => {
                    if (currentChartNumber === 0) return;
                    
                    const filterType = item.dataset.filter;
                    
                    if (activeMovementFilter === filterType) {
                        activeMovementFilter = null;
                        item.classList.remove('active-filter');
                    } else {
                        document.querySelectorAll('.legend-item').forEach(i => {
                            i.classList.remove('active-filter');
                        });
                        
                        activeMovementFilter = filterType;
                        item.classList.add('active-filter');
                    }
                    
                    applyFilters();
                });
            });
        });
    </script>
</body>
</html>