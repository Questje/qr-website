<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questje's ReQuestje's</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <h1>üéµ Questje's ReQuestje's Charts üéµ </h1>
            <div class="controls">
                <button id="prevChart" class="nav-button">
                    ‚Üê PREVIOUS
                </button>
                
                <div class="chart-selector-group">
                    <label for="chartSelector">Select Chart:</label>
                    <select id="chartSelector">
                        {% if has_data %}
                            <option value="0">All Songs</option>
                            {% for i in range(1, num_charts + 1) %}
                                <option value="{{ i }}" {% if i == num_charts %}selected{% endif %}>
                                    Chart {{ i }}
                                </option>
                            {% endfor %}
                        {% else %}
                            <option value="0">No Data Available</option>
                        {% endif %}
                    </select>
                </div>
                
                <button id="nextChart" class="nav-button">
                    NEXT ‚Üí
                </button>
                
                <span id="loadingIndicator" class="loading-hidden">Loading...</span>
            </div>
        </header>

        <main>
            {% if has_data %}
                <h2>
                  Questje's ReQuestje's #<span id="currentChart"></span>
                </h2>
                
                <!-- Filters Section -->
                <div class="filters-container">
                    <div class="filter-group">
                        <label for="songFilter">Filter by Song:</label>
                        <input type="text" id="songFilter" placeholder="Type to search..." class="song-filter-input">
                        <button id="clearFilter" class="clear-filter-btn">Clear</button>
                    </div>
                    <div class="filter-status" id="filterStatus"></div>
                </div>
                
                <div class="chart-legend" id="chartLegend">
                    <span class="legend-item clickable" data-filter="new"><span class="legend-color new"></span> New Entry <span class="count" id="countNew">(0)</span></span>
                    <span class="legend-item clickable" data-filter="riser"><span class="legend-color riser"></span> Riser <span class="count" id="countRiser">(0)</span></span>
                    <span class="legend-item clickable" data-filter="same"><span class="legend-color same"></span> No Change <span class="count" id="countSame">(0)</span></span>
                    <span class="legend-item clickable" data-filter="faller"><span class="legend-color faller"></span> Faller <span class="count" id="countFaller">(0)</span></span>
                    <span class="legend-item clickable" data-filter="reentry"><span class="legend-color reentry"></span> Re-entry <span class="count" id="countReentry">(0)</span></span>
                </div>
                
                <table id="chartTable">
                    <thead>
                        <tr>
                            <th data-column="position" class="sortable compact-column">
                                Pos <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="prev_position" class="sortable compact-column">
                                Prev <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="title" class="sortable song-title-column">
                                Song Title <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="total_charts" class="sortable charts-column">
                                Charts <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="top_spot" class="sortable top-spot-column">
                                Top Spot <span class="sort-arrow">‚Üï</span>
                            </th>
                            <th data-column="total_points" class="sortable points-column">
                                Total Points <span class="sort-arrow">‚Üï</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="chartBody">
                        <!-- Data will be loaded here via JavaScript -->
                    </tbody>
                </table>
            {% else %}
                <div class="error-message">
                    <h2>‚ö†Ô∏è No Data Available</h2>
                    <p>Please ensure the Chart.xlsx file is in the correct location and properly formatted.</p>
                </div>
            {% endif %}
        </main>

        <footer>
            <p>Questje's ReQuestje's ¬© 2025 | <span id="songCount"></span> total songs across <span id="chartCount"></span> charts</p>
        </footer>
    </div>

    <!-- Chart History Popup -->
    <div id="chartHistoryPopup" class="chart-history-popup" style="display: none;">
        <div class="popup-header">
            <span id="popupSongTitle"></span>
            <button id="closePopup" class="close-popup">√ó</button>
        </div>
        <canvas id="historyChart" width="300" height="150"></canvas>
    </div>

    <script>
        let currentData = [];
        let filteredData = [];
        let currentSortColumn = 'position';
        let currentSortDirection = 'asc';
        let currentChartNumber = {{ num_charts if has_data else 1 }};
        const maxCharts = {{ num_charts if has_data else 1 }};
        let currentHoverTimeout = null;
        let activeMovementFilter = null;
        let activeSongFilter = '';

        // Load chart data
        async function loadChart(chartNumber) {
            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.classList.remove('loading-hidden');
            
            try {
                const response = await fetch(`/api/chart/${chartNumber}`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading chart:', data.error);
                    return;
                }
                
                currentData = data.data;
                filteredData = [...currentData];
                currentChartNumber = chartNumber;
                currentSortColumn = 'position';
                currentSortDirection = 'asc';
                document.getElementById('currentChart').textContent = data.chart_number ? data.chart_number : "ALL-TIME"
                
                // Reset filters when changing charts
                activeMovementFilter = null;
                activeSongFilter = '';
                document.getElementById('songFilter').value = '';
                updateFilterStatus();
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active-filter');
                });

                // Update selector
                document.getElementById('chartSelector').value = currentChartNumber;
                
                // Update button states
                updateNavigationButtons();
                
                // Update legend counts
                updateLegendCounts(data.movement_counts);
                
                // Show/hide legend based on chart type and update clickability
                const legend = document.getElementById('chartLegend');
                if (chartNumber === 0) {
                    legend.style.display = 'none';
                    document.querySelectorAll('.legend-item').forEach(item => {
                        item.classList.remove('clickable');
                    });
                } else {
                    legend.style.display = 'flex';
                    document.querySelectorAll('.legend-item').forEach(item => {
                        item.classList.add('clickable');
                    });
                }
                
                renderTable();
            } catch (error) {
                console.error('Failed to load chart:', error);
            } finally {
                loadingIndicator.classList.add('loading-hidden');
            }
        }

        // Update legend counts
        function updateLegendCounts(counts) {
            if (counts) {
                document.getElementById('countNew').textContent = `(${counts.new || 0})`;
                document.getElementById('countRiser').textContent = `(${counts.riser || 0})`;
                document.getElementById('countSame').textContent = `(${counts.same || 0})`;
                document.getElementById('countFaller').textContent = `(${counts.faller || 0})`;
                document.getElementById('countReentry').textContent = `(${counts.reentry || 0})`;
            }
        }

        // Update navigation button states
        function updateNavigationButtons() {
            document.getElementById('prevChart').disabled = currentChartNumber <= 0;
            document.getElementById('nextChart').disabled = currentChartNumber >= maxCharts;
        }

        // Navigate to previous/next chart
        function navigateChart(direction) {
            const newChartNumber = currentChartNumber + direction;
            if (newChartNumber >= 0 && newChartNumber <= maxCharts) {
                loadChart(newChartNumber);
            }
        }

        // Format song title with #1 label
        function formatSongTitle(title, numberOnes) {
            if (numberOnes > 0) {
                return `${title} <span class="number-one-label">${numberOnes}x #1</span>`;
            }
            return title;
        }

        // Show chart history popup
        async function showChartHistory(songTitle, event) {
            try {
                const response = await fetch(`/api/song-history/${encodeURIComponent(songTitle)}`);
                const data = await response.json();
                
                if (data.error) {
                    console.error('Error loading song history:', data.error);
                    return;
                }
                
                const popup = document.getElementById('chartHistoryPopup');
                const canvas = document.getElementById('historyChart');
                const ctx = canvas.getContext('2d');
                
                // Set popup title
                document.getElementById('popupSongTitle').textContent = data.title;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (data.chart_data.length === 0) {
                    // No data to show
                    ctx.fillStyle = '#666';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No chart data available', canvas.width / 2, canvas.height / 2);
                } else {
                    // Draw the chart
                    drawLineChart(ctx, canvas, data.chart_data, currentChartNumber);
                }
                
                // Position popup near the mouse, but keep it within viewport
                const rect = popup.getBoundingClientRect();
                let left = event.pageX + 10;
                let top = event.pageY - rect.height / 2;
                
                // Adjust if popup would go off screen
                if (left + rect.width > window.innerWidth) {
                    left = event.pageX - rect.width - 10;
                }
                if (top < 10) {
                    top = 10;
                } else if (top + rect.height > window.innerHeight - 10) {
                    top = window.innerHeight - rect.height - 10;
                }
                
                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
                popup.style.display = 'block';
                
            } catch (error) {
                console.error('Failed to load song history:', error);
            }
        }

        // Draw line chart for song history
        function drawLineChart(ctx, canvas, data, currentChart) {
            const padding = 25;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Filter data to only include charts up to currentChart (or all if in All Songs view)
            const filteredData = currentChart === 0 ? data : data.filter(d => d.chart <= currentChart);
            
            if (filteredData.length === 0) return;
            
            // Find min and max values
            const positions = filteredData.map(d => d.position);
            const maxPosition = Math.max(...positions);
            const minPosition = Math.min(...positions);
            const positionRange = maxPosition - minPosition || 1;
            
            const charts = filteredData.map(d => d.chart);
            const minChart = Math.min(...charts);
            const maxChart = Math.max(...charts);
            const chartRange = maxChart - minChart || 1;
            
            // Draw axes (subtle)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Add axis labels
            ctx.fillStyle = '#999';
            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            
            // Y-axis labels (positions - now correctly oriented with #1 at top)
            ctx.save();
            ctx.translate(10, padding);
            ctx.textAlign = 'right';
            ctx.fillText(`#${minPosition}`, 0, 5);
            ctx.restore();
            
            ctx.save();
            ctx.translate(10, canvas.height - padding);
            ctx.textAlign = 'right';
            ctx.fillText(`#${maxPosition}`, 0, -2);
            ctx.restore();
            
            // X-axis labels (chart numbers)
            ctx.textAlign = 'center';
            ctx.fillText(`${minChart}`, padding, canvas.height - padding + 12);
            ctx.fillText(`${maxChart}`, canvas.width - padding, canvas.height - padding + 12);
            
            // Draw the line chart
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            filteredData.forEach((point, index) => {
                const x = padding + ((point.chart - minChart) / chartRange) * width;
                // Position 1 at top, higher positions lower (correct orientation)
                const y = padding + ((point.position - minPosition) / positionRange) * height;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#3498db';
            filteredData.forEach((point) => {
                const x = padding + ((point.chart - minChart) / chartRange) * width;
                const y = padding + ((point.position - minPosition) / positionRange) * height;
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Highlight #1 positions
                if (point.position === 1) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.strokeStyle = '#3498db';
                }
            });
            
            // Draw position labels for key points
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // Show first, last, and #1 positions
            filteredData.forEach((point, index) => {
                if (index === 0 || index === filteredData.length - 1 || point.position === 1) {
                    const x = padding + ((point.chart - minChart) / chartRange) * width;
                    const y = padding + ((point.position - minPosition) / positionRange) * height;
                    
                    ctx.fillText(`#${point.position}`, x, y - 8);
                }
            });
        }

        // Hide chart history popup
        function hideChartHistory() {
            document.getElementById('chartHistoryPopup').style.display = 'none';
        }
        
        // Get color for top spot position - gradient from green (#1) to red (worst)
        function getTopSpotColor(position) {
            if (!position || position > 100) return '#999999';
            
            // Create gradient from green (0) to yellow (50) to red (100)
            const ratio = Math.min(position - 1, 99) / 99; // Normalize to 0-1
            
            let r, g, b;
            if (ratio < 0.5) {
                // Green to Yellow
                const localRatio = ratio * 2;
                r = Math.round(255 * localRatio);
                g = 255;
                b = 0;
            } else {
                // Yellow to Red
                const localRatio = (ratio - 0.5) * 2;
                r = 255;
                g = Math.round(255 * (1 - localRatio));
                b = 0;
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Apply filters to data
        function applyFilters() {
            filteredData = [...currentData];
            
            // Apply song filter
            if (activeSongFilter) {
                filteredData = filteredData.filter(song => 
                    song.title.toLowerCase().includes(activeSongFilter.toLowerCase())
                );
            }
            
            // Apply movement filter (only for non-All Songs view)
            if (activeMovementFilter && currentChartNumber !== 0) {
                filteredData = filteredData.filter(song => 
                    song.movement_type === activeMovementFilter
                );
            }
            
            updateFilterStatus();
            renderTable();
        }
        
        // Update filter status message
        function updateFilterStatus() {
            const statusEl = document.getElementById('filterStatus');
            const filters = [];
            
            if (activeSongFilter) {
                filters.push(`Song contains "${activeSongFilter}"`);
            }
            
            if (activeMovementFilter) {
                const filterNames = {
                    'new': 'New Entries',
                    'riser': 'Risers',
                    'faller': 'Fallers',
                    'same': 'No Change',
                    'reentry': 'Re-entries'
                };
                filters.push(filterNames[activeMovementFilter]);
            }
            
            if (filters.length > 0) {
                statusEl.innerHTML = `<strong>Active filters:</strong> ${filters.join(' | ')} <span class="results-count">(${filteredData.length} results)</span>`;
                statusEl.style.display = 'block';
            } else {
                statusEl.style.display = 'none';
            }
        }

        // Render table with current data
        function renderTable() {
            const tbody = document.getElementById('chartBody');
            tbody.innerHTML = '';
            
            const isAllSongs = currentChartNumber === 0;
            
            if (filteredData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-results">No songs match the current filters</td></tr>';
                return;
            }
            
            filteredData.forEach((row, index) => {
                const tr = document.createElement('tr');
                tr.className = 'chart-row';
                
                // Add hover events for chart history
                tr.addEventListener('mouseenter', (e) => {
                    clearTimeout(currentHoverTimeout);
                    currentHoverTimeout = setTimeout(() => {
                        showChartHistory(row.title, e);
                    }, 500); // Show after 500ms hover
                });
                
                tr.addEventListener('mouseleave', () => {
                    clearTimeout(currentHoverTimeout);
                    // Don't hide immediately to allow moving to the popup
                    setTimeout(() => {
                        const popup = document.getElementById('chartHistoryPopup');
                        if (!popup.matches(':hover')) {
                            hideChartHistory();
                        }
                    }, 100);
                });
                
                // Determine position box class based on movement type
                let positionClass = 'position-number';
                let movementIcon = '';
                
                if (!isAllSongs) {
                    switch(row.movement_type) {
                        case 'new':
                            positionClass += ' new-entry';
                            movementIcon = '<span class="movement-icon">‚òÖ</span>';
                            break;
                        case 'reentry':
                            positionClass += ' reentry';
                            movementIcon = '<span class="movement-icon">‚Ü∫</span>';
                            break;
                        case 'riser':
                            positionClass += ' riser';
                            movementIcon = '<span class="movement-icon">‚Üë</span>';
                            break;
                        case 'faller':
                            positionClass += ' faller';
                            movementIcon = '<span class="movement-icon">‚Üì</span>';
                            break;
                        case 'same':
                            positionClass += ' same';
                            movementIcon = '<span class="movement-icon">‚Üí</span>';
                            break;
                    }
                } else {
                    // For "All Songs" view, color by ranking
                    if (row.position <= 3) {
                        positionClass += ' top-three';
                    } else if (row.position <= 10) {
                        positionClass += ' top-ten';
                    } else {
                        positionClass += ' same';
                    }
                }
                
                // Get top spot color
                //const topSpotColor = getTopSpotColor(row.top_spot || 999);
                const topSpotColor = '#474747ff';
                const topSpotDisplay = row.top_spot ? 
                    `<span style="color: ${topSpotColor}; font-weight: bold;">${row.top_spot}</span>` : 
                    '<span style="color: #999;">--</span>';
                
                tr.innerHTML = `
                    <td class="position-cell compact-cell">
                        <div class="position-wrapper">
                            <span class="${positionClass}">${row.position}</span>
                            ${movementIcon}
                        </div>
                    </td>
                    <td class="prev-position-cell compact-cell">${row.prev_position}</td>
                    <td class="title-cell">${formatSongTitle(row.title, row.number_ones)}</td>
                    <td class="charts-cell compact-cell">${row.total_charts}</td>
                    <td class="top-spot-cell compact-cell">
                        ${topSpotDisplay}
                    </td>
                    <td class="points-cell compact-cell">${row.total_points}</td>
                `;
                
                tbody.appendChild(tr);
            });
        }

        // Sort table
        function sortTable(column) {
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = column === 'total_points' ? 'desc' : 'asc';
            }
            
            filteredData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];
                
                // Handle special cases
                if (column === 'prev_position') {
                    aVal = aVal === '--' ? 999 : parseInt(aVal);
                    bVal = bVal === '--' ? 999 : parseInt(bVal);
                }
                
                if (column === 'top_spot') {
                    aVal = aVal === null || aVal === undefined ? 999 : aVal;
                    bVal = bVal === null || bVal === undefined ? 999 : bVal;
                }
                
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }
                
                if (currentSortDirection === 'asc') {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            renderTable();
            updateSortIndicators();
        }

        // Update sort indicators
        function updateSortIndicators() {
            document.querySelectorAll('th.sortable').forEach(th => {
                const arrow = th.querySelector('.sort-arrow');
                if (th.dataset.column === currentSortColumn) {
                    arrow.textContent = currentSortDirection === 'asc' ? '‚Üë' : '‚Üì';
                    th.classList.add('sorted');
                } else {
                    arrow.textContent = '‚Üï';
                    th.classList.remove('sorted');
                }
            });
        }

        // Load info
        async function loadInfo() {
            try {
                const response = await fetch('/api/info');
                const data = await response.json();
                document.getElementById('songCount').textContent = data.num_songs;
                document.getElementById('chartCount').textContent = data.num_charts;
            } catch (error) {
                console.error('Failed to load info:', error);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Load initial data
            {% if has_data %}
                loadChart({{ num_charts }});
                loadInfo();
                
                // Initialize filters container visibility
                document.querySelector('.filters-container').style.display = 'flex';
            {% endif %}
            
            // Chart selector
            document.getElementById('chartSelector').addEventListener('change', (e) => {
                loadChart(parseInt(e.target.value));
            });
            
            // Navigation buttons
            document.getElementById('prevChart').addEventListener('click', () => {
                navigateChart(-1);
            });
            
            document.getElementById('nextChart').addEventListener('click', () => {
                navigateChart(1);
            });
            
            // Close popup button
            document.getElementById('closePopup').addEventListener('click', hideChartHistory);
            
            // Keep popup open when hovering over it
            document.getElementById('chartHistoryPopup').addEventListener('mouseenter', () => {
                clearTimeout(currentHoverTimeout);
            });
            
            document.getElementById('chartHistoryPopup').addEventListener('mouseleave', hideChartHistory);
            
            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && !e.target.matches('input, select, textarea')) {
                    navigateChart(-1);
                } else if (e.key === 'ArrowRight' && !e.target.matches('input, select, textarea')) {
                    navigateChart(1);
                } else if (e.key === 'Escape') {
                    hideChartHistory();
                }
            });
            
            // Sort headers
            document.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    sortTable(th.dataset.column);
                });
            });
            
            // Song filter input
            document.getElementById('songFilter').addEventListener('input', (e) => {
                activeSongFilter = e.target.value.trim();
                applyFilters();
            });
            
            // Clear filter button
            document.getElementById('clearFilter').addEventListener('click', () => {
                document.getElementById('songFilter').value = '';
                activeSongFilter = '';
                applyFilters();
            });
            
            // Movement filter clicks
            document.querySelectorAll('.legend-item.clickable').forEach(item => {
                item.addEventListener('click', () => {
                    // Don't allow movement filters in All Songs view
                    if (currentChartNumber === 0) return;
                    
                    const filterType = item.dataset.filter;
                    
                    // Toggle filter
                    if (activeMovementFilter === filterType) {
                        activeMovementFilter = null;
                        item.classList.remove('active-filter');
                    } else {
                        // Remove active class from all items
                        document.querySelectorAll('.legend-item').forEach(i => {
                            i.classList.remove('active-filter');
                        });
                        
                        activeMovementFilter = filterType;
                        item.classList.add('active-filter');
                    }
                    
                    applyFilters();
                });
            });
        });
    </script>
</body>
</html>
