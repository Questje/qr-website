<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ song_title }} - Questje's ReQuestje's</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <div class="header-left">
                    <h1><a href="/" class="back-link">üéµ Questje's ReQuestje's Charts üéµ</a></h1>
                </div>
                <!-- Auth section - persists across all pages -->
                <div class="auth-section" id="authSection">
                    <!-- Login/User info will be inserted here by JavaScript -->
                </div>
            </div>
            <div class="back-button-container">
                <button class="back-to-charts-btn" onclick="window.location.href='/'">
                    ‚Üê Back to Charts
                </button>
            </div>
        </header>

        <main class="song-page">
            <div class="song-header">
                <h2 id="songTitle"></h2>
                <div class="song-stats">
                    <div class="stat-item">
                        <span class="stat-label">Total Charts:</span>
                        <span class="stat-value" id="totalCharts">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg Position:</span>
                        <span class="stat-value" id="avgPosition">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Best Position:</span>
                        <span class="stat-value" id="bestPosition">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Worst Position:</span>
                        <span class="stat-value" id="worstPosition">-</span>
                    </div>
                </div>
            </div>

            <div class="song-content">
                <div class="chart-container">
                    <h3>Chart History</h3>
                    <canvas id="songChart" width="800" height="400"></canvas>
                </div>

                <div class="comments-section">
                    <h3>Comments</h3>
                    <div id="commentsLoginMessage" class="comments-login-message" style="display: none;">
                        <p>Please <button onclick="loginWithTwitch()" class="inline-login-btn">login with Twitch</button> to post comments.</p>
                    </div>
                    <div id="commentsForm" class="comment-input-area" style="display: none;">
                        <input type="text" id="commentName" placeholder="Name" maxlength="50" class="comment-input" readonly>
                        <textarea id="commentText" placeholder="Add a comment..." maxlength="200" class="comment-textarea"></textarea>
                        <div class="char-counter">
                            <span id="charCount">0</span>/200
                        </div>
                        <button id="submitComment" class="submit-comment-btn">Post Comment</button>
                    </div>
                    <div id="commentsList" class="comments-list"></div>
                    <div id="commentsPagination" class="comments-pagination" style="display: none;">
                        <button id="prevPage" class="pagination-btn">‚Üê Previous</button>
                        <span id="pageInfo" class="page-info"></span>
                        <button id="nextPage" class="pagination-btn">Next ‚Üí</button>
                    </div>
                </div>
            </div>
        </main>

        <footer style="margin-top: 40px;">
            <p>Questje's ReQuestje's ¬© 2025</p>
        </footer>
    </div>

    <script>
        const songTitle = '{{ song_title }}';
        let chartDataGlobal = [];
        let statsGlobal = {};
        let currentUser = null;
        let currentUserProfilePic = null;
        let isAdmin = false;
        let allComments = [];
        let currentPage = 1;
        let commentsPerPage = 5;

        // Check authentication status on page load
        async function checkAuth() {
            try {
                const response = await fetch('/api/auth/status');
                const data = await response.json();
                if (data.logged_in) {
                    currentUser = data.username;
                    currentUserProfilePic = data.profile_pic;
                    isAdmin = data.is_admin || false;
                    document.getElementById('commentName').value = currentUser;
                    document.getElementById('commentsForm').style.display = 'flex';
                    document.getElementById('commentsLoginMessage').style.display = 'none';
                } else {
                    document.getElementById('commentsForm').style.display = 'none';
                    document.getElementById('commentsLoginMessage').style.display = 'block';
                }
                updateAuthDisplay();
            } catch (error) {
                console.error('Failed to check auth status:', error);
            }
        }

        // Update auth display in header
        function updateAuthDisplay() {
            const authSection = document.getElementById('authSection');
            
            if (currentUser) {
                // Build user info HTML with profile pic and icon on the right
                let html = '<div class="user-info">';
                html += `<span class="username">Logged in as: <strong>${currentUser}</strong></span>`;
                if (isAdmin) {
                    html += '<span class="admin-badge">ADMIN</span>';
                }
                if (currentUserProfilePic) {
                    html += `<img src="${currentUserProfilePic}" alt="${currentUser}" class="profile-pic-small">`;
                }
                html += '<i class="fab fa-twitch"></i>';
                html += '<button class="logout-btn" onclick="logout()">Logout</button>';
                html += '</div>';
                authSection.innerHTML = html;
            } else {
                authSection.innerHTML = `
                    <button class="login-btn" onclick="loginWithTwitch()">
                        <i class="fab fa-twitch"></i> Login with Twitch
                    </button>
                `;
            }
        }

        // Login with Twitch
        function loginWithTwitch() {
            window.location.href = '/auth/login';
        }

        // Logout
        async function logout() {
            try {
                const response = await fetch('/auth/logout', { method: 'POST' });
                if (response.ok) {
                    currentUser = null;
                    currentUserProfilePic = null;
                    isAdmin = false;
                    location.reload();
                }
            } catch (error) {
                console.error('Failed to logout:', error);
            }
        }

        // Load song data
        async function loadSongData() {
            try {
                const response = await fetch(`/api/song/${encodeURIComponent(songTitle)}`);
                const data = await response.json();

                if (data.error) {
                    alert('Song not found: ' + data.error);
                    window.location.href = '/';
                    return;
                }

                chartDataGlobal = data.chart_data;
                statsGlobal = data.stats;

                // Update page
                document.getElementById('songTitle').textContent = data.title;
                document.getElementById('totalCharts').textContent = statsGlobal.total_charts;
                document.getElementById('avgPosition').textContent = statsGlobal.avg_position.toFixed(1);
                document.getElementById('bestPosition').textContent = statsGlobal.best_position;
                document.getElementById('worstPosition').textContent = statsGlobal.worst_position;

                // Draw chart with animation
                drawSongChart();
                
                // Load comments
                loadComments();

            } catch (error) {
                console.error('Failed to load song data:', error);
                alert('Error loading song data');
            }
        }

        // Draw the main song chart with smooth animation that hits all data points
        function drawSongChart() {
            const canvas = document.getElementById('songChart');
            const ctx = canvas.getContext('2d');

            const padding = 40;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;

            if (chartDataGlobal.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No chart data available', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Get position range
            const positions = chartDataGlobal.map(d => d.position);
            const minPos = Math.min(...positions);
            const maxPos = Math.max(...positions);
            const posRange = maxPos - minPos || 1;

            const chartNums = chartDataGlobal.map(d => d.chart);
            const minChart = Math.min(...chartNums);
            const maxChart = Math.max(...chartNums);
            const chartRange = maxChart - minChart || 1;

            // Animation variables
            const animationDuration = 3000; // 3 seconds
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background grid
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = padding + (i / 10) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(canvas.width - padding, y);
                    ctx.stroke();
                }

                // Draw axes
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();

                // Draw axis labels (bigger font size)
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'right';

                // Y-axis label (#1 at top)
                ctx.fillText(`#${minPos}`, padding - 5, padding + 5);
                ctx.fillText(`#${maxPos}`, padding - 5, canvas.height - padding + 5);

                // X-axis labels (only show charts where the song appeared)
                ctx.textAlign = 'center';
                chartDataGlobal.forEach((point) => {
                    const x = padding + ((point.chart - minChart) / chartRange) * chartWidth;
                    ctx.fillText(`${point.chart}`, x, canvas.height - padding + 20);
                });

                // Calculate how many points to show based on animation progress
                const totalPoints = chartDataGlobal.length;
                const pointsToShow = Math.floor(totalPoints * progress);
                const partialProgress = (totalPoints * progress) % 1;

                if (pointsToShow > 0) {
                    // Prepare points for drawing
                    const points = chartDataGlobal.slice(0, pointsToShow).map(point => ({
                        x: padding + ((point.chart - minChart) / chartRange) * chartWidth,
                        y: padding + ((point.position - minPos) / posRange) * chartHeight,
                        chart: point.chart,
                        position: point.position
                    }));

                    // Add partial point if animation is in progress
                    if (progress < 1 && pointsToShow < totalPoints) {
                        const currentPoint = chartDataGlobal[pointsToShow - 1];
                        const nextPoint = chartDataGlobal[pointsToShow];
                        if (nextPoint) {
                            const currentX = padding + ((currentPoint.chart - minChart) / chartRange) * chartWidth;
                            const currentY = padding + ((currentPoint.position - minPos) / posRange) * chartHeight;
                            const nextX = padding + ((nextPoint.chart - minChart) / chartRange) * chartWidth;
                            const nextY = padding + ((nextPoint.position - minPos) / posRange) * chartHeight;
                            
                            const interpolatedX = currentX + (nextX - currentX) * partialProgress;
                            const interpolatedY = currentY + (nextY - currentY) * partialProgress;
                            
                            points.push({ 
                                x: interpolatedX, 
                                y: interpolatedY, 
                                chart: currentPoint.chart + (nextPoint.chart - currentPoint.chart) * partialProgress,
                                position: currentPoint.position + (nextPoint.position - currentPoint.position) * partialProgress,
                                isPartial: true
                            });
                        }
                    }

                    // Draw smooth line using cardinal spline that passes through all points
                    if (points.length > 0) {
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2.5;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        if (points.length === 1) {
                            // Single point - just draw it
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);
                            ctx.lineTo(points[0].x, points[0].y);
                        } else if (points.length === 2) {
                            // Two points - straight line
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);
                            ctx.lineTo(points[1].x, points[1].y);
                        } else {
                            // Multiple points - use cardinal spline for smooth curves through points
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);

                            for (let i = 1; i < points.length - 1; i++) {
                                const p0 = points[i - 1];
                                const p1 = points[i];
                                const p2 = points[i + 1];
                                
                                // Calculate control points for smooth curve
                                const tension = 0.3; // Adjust tension for smoothness
                                const cp1x = p1.x + tension * (p2.x - p0.x) / 6;
                                const cp1y = p1.y + tension * (p2.y - p0.y) / 6;
                                const cp2x = p2.x - tension * (p2.x - p0.x) / 6;
                                const cp2y = p2.y - tension * (p2.y - p0.y) / 6;

                                if (i === 1) {
                                    // First curve
                                    ctx.bezierCurveTo(
                                        p0.x + tension * (p1.x - p0.x) / 3,
                                        p0.y + tension * (p1.y - p0.y) / 3,
                                        cp1x,
                                        cp1y,
                                        p1.x,
                                        p1.y
                                    );
                                }

                                // Curve to next point
                                ctx.bezierCurveTo(
                                    p1.x + tension * (p2.x - p1.x) / 3,
                                    p1.y + tension * (p2.y - p1.y) / 3,
                                    cp2x,
                                    cp2y,
                                    p2.x,
                                    p2.y
                                );
                            }

                            // Handle last segment if we have a partial point
                            if (points.length >= 2) {
                                const lastComplete = points.length - (points[points.length - 1].isPartial ? 2 : 1);
                                const lastPoint = points[points.length - 1];
                                
                                if (lastPoint.isPartial && lastComplete >= 0) {
                                    const prevPoint = points[lastComplete];
                                    ctx.lineTo(lastPoint.x, lastPoint.y);
                                }
                            }
                        }

                        ctx.stroke();
                    }

                    // Draw data points and labels for completed points only
                    ctx.fillStyle = '#3498db';
                    for (let i = 0; i < pointsToShow; i++) {
                        const point = chartDataGlobal[i];
                        const x = padding + ((point.chart - minChart) / chartRange) * chartWidth;
                        const y = padding + ((point.position - minPos) / posRange) * chartHeight;

                        // Draw circle for data point
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI);
                        ctx.fill();

                        // Show position label above the point (bigger font size)
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`#${point.position}`, x, y - 12);
                        ctx.fillStyle = '#3498db';

                        // Highlight #1 positions
                        if (point.position === 1) {
                            ctx.strokeStyle = '#f39c12';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(x, y, 7, 0, 2 * Math.PI);
                            ctx.stroke();
                            ctx.strokeStyle = '#3498db';
                            ctx.lineWidth = 2.5;
                        }
                    }
                }

                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            // Start animation
            animate();
        }

        // Load comments for the song with pagination
        async function loadComments() {
            try {
                const response = await fetch(`/api/comments/${encodeURIComponent(songTitle)}`);
                const data = await response.json();

                allComments = data.comments;
                displayComments();

            } catch (error) {
                console.error('Failed to load comments:', error);
            }
        }

        // Display comments with pagination
        function displayComments() {
            const commentsList = document.getElementById('commentsList');
            const pagination = document.getElementById('commentsPagination');
            
            if (allComments.length === 0) {
                commentsList.innerHTML = '<p class="no-comments">No comments yet. Be the first to comment!</p>';
                pagination.style.display = 'none';
                return;
            }

            // Calculate pagination
            const totalPages = Math.ceil(allComments.length / commentsPerPage);
            const startIndex = (currentPage - 1) * commentsPerPage;
            const endIndex = startIndex + commentsPerPage;
            const commentsToShow = allComments.slice(startIndex, endIndex);

            // Clear comments list
            commentsList.innerHTML = '';

            // Sort by date (newest first)
            commentsToShow.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            commentsToShow.forEach(comment => {
                const commentDiv = document.createElement('div');
                commentDiv.className = 'comment-item';
                commentDiv.id = `comment-${comment.id}`;

                const date = new Date(comment.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

                let authorHTML = `<strong class="comment-author">${escapeHtml(comment.user)}</strong>`;
                
                // Add profile pic if available
                if (comment.profile_pic) {
                    authorHTML = `<img src="${comment.profile_pic}" alt="${comment.user}" class="comment-profile-pic"> ` + authorHTML;
                }

                // Add edit/delete buttons if user owns comment or is admin
                let actionsHTML = '';
                if (currentUser && (currentUser === comment.user || isAdmin)) {
                    actionsHTML = `
                        <div class="comment-actions">
                            <button class="edit-btn" onclick="startEdit(${comment.id})">
                                <i class="fas fa-edit"></i>
                            </button>
                            ${isAdmin ? `<button class="delete-btn" onclick="deleteComment(${comment.id})">
                                <i class="fas fa-trash"></i>
                            </button>` : ''}
                        </div>
                    `;
                }

                // Likes section
                const likeCount = comment.like_count || 0;
                const likedBy = comment.liked_by || [];
                const userLiked = likedBy.includes(currentUser);
                const likeButtonClass = userLiked ? 'liked' : '';
                
                // Show max 5 names in tooltip
                let tooltipText = '';
                if (likedBy.length > 0) {
                    const displayNames = likedBy.slice(0, 5);
                    tooltipText = `Liked by: ${displayNames.join(', ')}`;
                    if (likedBy.length > 5) {
                        tooltipText += ` and ${likedBy.length - 5} more`;
                    }
                }
                const likeTooltip = tooltipText ? `title="${tooltipText}"` : '';

                const likesHTML = currentUser ? `
                    <div class="comment-likes">
                        <button class="like-btn ${likeButtonClass}" onclick="toggleLike(${comment.id})" ${likeTooltip}>
                            <i class="fas fa-thumbs-up"></i>
                            <span class="like-count">${likeCount}</span>
                        </button>
                    </div>
                ` : (likeCount > 0 ? `
                    <div class="comment-likes">
                        <span class="like-display" ${likeTooltip}>
                            <i class="fas fa-thumbs-up"></i>
                            <span class="like-count">${likeCount}</span>
                        </span>
                    </div>
                ` : '');

                commentDiv.innerHTML = `
                    <div class="comment-header">
                        <div class="comment-author-info">
                            ${authorHTML}
                        </div>
                        <div class="comment-right">
                            <span class="comment-date">${dateStr}</span>
                            ${actionsHTML}
                        </div>
                    </div>
                    <div class="comment-text" id="text-${comment.id}">${escapeHtml(comment.text)}</div>
                    <div class="comment-edit" id="edit-${comment.id}" style="display: none;">
                        <textarea class="edit-textarea" maxlength="200">${escapeHtml(comment.text)}</textarea>
                        <div class="edit-actions">
                            <button class="save-btn" onclick="saveEdit(${comment.id})">Save</button>
                            <button class="cancel-btn" onclick="cancelEdit(${comment.id})">Cancel</button>
                        </div>
                    </div>
                    ${likesHTML}
                `;

                commentsList.appendChild(commentDiv);
            });

            // Update pagination
            if (totalPages > 1) {
                pagination.style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                pagination.style.display = 'none';
            }
        }

        // In-place editing functions
        function startEdit(commentId) {
            document.getElementById(`text-${commentId}`).style.display = 'none';
            document.getElementById(`edit-${commentId}`).style.display = 'block';
        }

        function cancelEdit(commentId) {
            document.getElementById(`text-${commentId}`).style.display = 'block';
            document.getElementById(`edit-${commentId}`).style.display = 'none';
        }

        async function saveEdit(commentId) {
            const textarea = document.querySelector(`#edit-${commentId} .edit-textarea`);
            const newText = textarea.value.trim();
            
            if (!newText) {
                alert('Comment cannot be empty');
                return;
            }

            try {
                const response = await fetch(`/api/comments/${commentId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: newText
                    })
                });

                if (response.ok) {
                    // Update the text display
                    document.getElementById(`text-${commentId}`).textContent = newText;
                    cancelEdit(commentId);
                    // Refresh comments to get updated data
                    loadComments();
                } else {
                    alert('Failed to update comment');
                }
            } catch (error) {
                console.error('Failed to update comment:', error);
                alert('Error updating comment');
            }
        }

        // Toggle like
        async function toggleLike(commentId) {
            try {
                const response = await fetch(`/api/comments/${commentId}/like`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadComments(); // Reload to update like counts
                } else {
                    alert('Failed to toggle like');
                }
            } catch (error) {
                console.error('Failed to toggle like:', error);
                alert('Error toggling like');
            }
        }

        // Pagination handlers
        document.getElementById('prevPage')?.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                displayComments();
            }
        });

        document.getElementById('nextPage')?.addEventListener('click', () => {
            const totalPages = Math.ceil(allComments.length / commentsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                displayComments();
            }
        });

        // Delete comment (admin only)
        async function deleteComment(commentId) {
            if (!confirm('Are you sure you want to delete this comment?')) {
                return;
            }

            try {
                const response = await fetch(`/api/comments/${commentId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    loadComments();
                } else {
                    alert('Failed to delete comment');
                }
            } catch (error) {
                console.error('Failed to delete comment:', error);
                alert('Error deleting comment');
            }
        }

        // Character counter
        function updateCharCount() {
            const textarea = document.getElementById('commentText');
            const counter = document.getElementById('charCount');
            if (textarea && counter) {
                counter.textContent = textarea.value.length;
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Submit a new comment
        document.addEventListener('DOMContentLoaded', () => {
            const submitBtn = document.getElementById('submitComment');
            const textarea = document.getElementById('commentText');
            
            // Add character counter
            if (textarea) {
                textarea.addEventListener('input', updateCharCount);
            }
            
            if (submitBtn) {
                submitBtn.addEventListener('click', async () => {
                    const name = document.getElementById('commentName').value.trim();
                    const text = document.getElementById('commentText').value.trim();

                    if (!name || !text) {
                        alert('Please fill in both name and comment');
                        return;
                    }

                    if (text.length > 200) {
                        alert('Comment must be 200 characters or less');
                        return;
                    }

                    try {
                        const response = await fetch('/api/comments', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                song_title: songTitle,
                                user: name,
                                text: text
                            })
                        });

                        if (response.ok) {
                            document.getElementById('commentText').value = '';
                            updateCharCount();
                            loadComments();
                        } else {
                            alert('Failed to post comment');
                        }
                    } catch (error) {
                        console.error('Failed to post comment:', error);
                        alert('Error posting comment');
                    }
                });
            }

            // Load page data
            checkAuth();
            loadSongData();
        });
    </script>

    <style>
        .admin-badge {
            background: #f39c12;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        .comments-section {
            margin-bottom: 30px; /* Add space before footer */
        }

        .comments-list {
            max-height: 500px; /* Limit height to prevent overlap */
            overflow-y: auto; /* Add scrolling if needed for more than 5 comments */
            padding-right: 10px; /* Space for scrollbar */
        }

        .comment-item {
            margin-bottom: 20px; /* Space between comments */
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border-left: 3px solid #3498db;
        }

        .comment-item:last-child {
            margin-bottom: 0; /* Remove margin from last comment */
        }

        .comments-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        .pagination-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .pagination-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 14px;
            color: #666;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .comment-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .comment-actions {
            display: flex;
            gap: 5px;
        }

        .edit-btn, .delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            font-size: 12px;
        }

        .edit-btn {
            color: #3498db;
        }

        .edit-btn:hover {
            background: #3498db;
            color: white;
        }

        .delete-btn {
            color: #e74c3c;
        }

        .delete-btn:hover {
            background: #e74c3c;
            color: white;
        }

        .comment-edit {
            margin-top: 10px;
        }

        .edit-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
        }

        .edit-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .save-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .cancel-btn {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .comment-likes {
            margin-top: 10px;
            display: flex;
            justify-content: flex-end;
        }

        .like-btn, .like-display {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .like-btn:hover {
            background: #f0f0f0;
        }

        .like-btn.liked {
            color: #3498db;
        }

        .like-display {
            cursor: default;
        }

        .like-count {
            font-size: 11px;
        }

        .char-counter {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .comment-input-area {
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .song-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .chart-container {
            flex-shrink: 0; /* Prevent chart from shrinking */
        }

        /* Custom scrollbar for comments */
        .comments-list::-webkit-scrollbar {
            width: 6px;
        }

        .comments-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .comments-list::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 3px;
        }

        .comments-list::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        /* Ensure proper spacing in main layout */
        main.song-page {
            margin-bottom: 40px;
        }

        /* Adjust comment text area to allow for longer comments */
        .comment-text {
            line-height: 1.4;
            word-wrap: break-word;
            margin-top: 8px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .comments-list {
                max-height: 400px;
            }
            
            .comment-item {
                margin-bottom: 15px;
                padding: 12px;
            }
        }
    </style>
</body>
</html>
